#!/usr/bin/env perl
#
# Generate possible phrases using interval data and a starting pitch.

use strict;
use warnings;
use File::Slurp qw/read_file/;
use IPC::Open3 qw/open3/;
use JSON ();
use List::Util qw(sum);
use Music::AtonalUtil ();
use POSIX qw/floor/;

my $mau = Music::AtonalUtil->new;

my $r = 'dotslong';
my %rr = (
  dotslong => {
    ds => [qw/4. 8 8 8 8 8/],
    s  => 1,
    x  => 6,
  },
  dl2 => {
    ds => [qw/4 4 2/],
    s  => 0,
    x  => 3,
  },
  h => {
    ds => [qw/4/],
    s  => 0,
    x  => 1,
  },
);

# this is really neat with \times 2/3 and x of 3, but probably really
# tricky for a human to play.
#my @dur_seq = qw/4. 8 8 8/;

my %num2note = (
  'ly-sharp' =>
    {qw/0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b/},
  'ly-flat' =>
    {qw/0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b/},
);
my $num2note_flavor = 'ly-flat';
my %registers       = (
  -3 => ",,,",
  -2 => ",,",
  -1 => ",",
  0  => "",
  1  => "'",
  2  => "''",
  3  => "'''",
  4  => "''''",
  5  => "'''''"
);

my $interval_odds =
  JSON->new->decode( scalar read_file('base-intervals.json') );
my $style = 'class_raw';    # pitch_raw pitch_abs class_raw class_abs

my $intervals;
{
  my $sum  = sum values %{ $interval_odds->{$style} };
  my $cumm = 0;
  for my $k ( keys %{ $interval_odds->{$style} } ) {
    $cumm += $interval_odds->{$style}->{$k} / $sum;
    unshift @$intervals, [ $cumm, $k, $interval_odds->{$style}->{$k} ];
  }
}

my @pitches = $mau->notes2pitches( shift || 'd' );
while ( @pitches < 15 ) {
  my $rand = rand;
  my $choice;
  for my $i (@$intervals) { $choice = $i if $i->[0] >= $rand; }
  push @pitches, $pitches[-1] + $choice->[1];
}

my ( @notes, $prev_pitch );
for my $p (@pitches) {
  my $pitch   = $p % $mau->scale_degrees;
  my $reg_num = floor( $p / $mau->scale_degrees );

  # if ( defined $prev_pitch and $prev_pitch == $p ) {
  #   $notes[-1] .= '~';
  # }
  my $reg = $registers{$reg_num} || '';
  if ( length $reg > 1 ) {
    $reg = substr $reg, 0, 1;
  }
  my $dur = 'D';
  push @notes, $num2note{$num2note_flavor}->{$pitch} . $reg . $dur;

  $prev_pitch = $p;
}

my @notes2;
my $c = 0;
for my $n (@notes) {
  for ( 1 .. $rr{$r}->{x} || 1 ) {
    ( my $m = $n ) =~ s/D/$rr{$r}->{ds}->[ $rr{$r}->{s} ]/;
    $rr{$r}->{s} = ( $rr{$r}->{s} + 1 ) % @{ $rr{$r}->{ds} };
    push @notes2,   $m;
  }
  if ($r eq 'dotslong') {
    push @notes2, 'r2';
    $r = 'h';
  } else {
    $r = 'dotslong';
    push @notes2, 'r4';
  }
  $c++;
}
print join( ' ', @notes2 ), "\n";
