# Only for use with gen-*.pl scripts herein (mostly due to the otherwise
# naughty use of @EXPORT).

use strict;
use warnings;

package SharedMusic;
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT =
  qw(%Num2Note $Measures $Smallest_Note @Durs &increment_beat &reduce_rests &print_measure);

our $Measures = 47;
our %Num2Note =
  qw/0 e 1 f 2 fis 3 g 4 gis 5 a 6 ais 7 b 8 c 9 cis 10 d 11 dis/;

our @Durs = (
  [qw/4   4   4   4   4   4   4   4   4   4   4   8 8/],
  [qw/4   4   8 8 8 8 4   4   4   4   4   4   4   8 8/],
  [qw/4   4   4   8 8 4   8 8 4   8 8 4   8 8 8 8 4  /],
  [qw/4   4   4   4   8 8 8 8 4   8 8 8 8 4   8 8 8 8/],

  [qw/4   4   4   8 8 8 8 4   4   4   4   8 8 8 8 8 8/],
  [qw/4   4   4   4   8 8 8 8 4   4   4   4   8 8 4  /],
  [qw/4   8 8 4   8 8 4   8 8 8 8 8 8 4   8 8 8 8 4  /],
  [qw/4   4   8 8 8 8 4   4   8 8 4   8 8 4   4   8 8/],

  [qw/4   4   4   4   8 8 4   4   4   8 8 8 8 8 8 4  /],
  [qw/4   4   4   8 8 4   8 8 4   8 8 8 8 4   8 8 8 8/],
  [qw/8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8/],
  [qw/4   4   8 8 4   4   4   8 8 8 8 4   4   4   8 8/],
);
our $Smallest_Note = 8;

sub increment_beat {
  my $duration = shift;
  return 1 / ( $duration / $Smallest_Note );
}

sub reduce_rests {
  my $notes = shift;

  my $next = 1;
  for ( my $i = 0; $i < @$notes; $i += $next ) {
    if ( $notes->[$i]->{'note'} =~ m/^[rs]/ ) {
      $notes->[$i]->{'fold_duration'} =
        increment_beat( $notes->[$i]->{'duration'} );
      my $j = 1;
      while ( $j < @$notes and $notes->[$j]->{'note'} =~ m/^[rs]/ ) {
        $notes->[$j]->{'folded'} = 1;
        $notes->[$i]->{'fold_duration'} +=
          increment_beat( $notes->[$j]->{'duration'} );
        $j++;
      }
      $next = $j;
    } else {
      $next = 1;
    }
  }
}

sub _unfold_rests {
  my $notes    = shift;
  my $duration = shift;
  my $note     = shift || 1;

  my $count = int( $duration / increment_beat($note) );
  if ( $count > 0 ) {
    push @$notes, { duration => $note } for 1 .. $count;
  }
  my $remainder = $duration % increment_beat($note);
  if ( $remainder > 0 ) {
    _unfold_rests( $notes, $remainder, $note * 2 );
  }
}

sub print_measure {
  my $notes       = shift;
  my $measure_num = shift;

  for my $c (@$notes) {
    next if exists $c->{'folded'};
    delete @{$c}{qw/register accent/} if $c->{'note'} =~ m/^[rs]/;
    if ( exists $c->{'fold_duration'} ) {
      my @rests;
      _unfold_rests( \@rests, $c->{'fold_duration'} );
      my $first = shift @rests;
      print_note( { %$c, %$first } );
      for my $r (@rests) {
        print_note( { note => $c->{'note'}, %$r } );
      }
    } else {
      print_note($c);
    }
  }
  print "\t|\n" unless $measure_num == $Measures;
}

sub print_note {
  my $note = shift;
  print join( '',
    "\t",
    map { exists $note->{$_} ? $note->{$_} : () }
      qw/note register duration accent volume/ );
}

print "% generated by $0\n";

1;
