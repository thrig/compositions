;;;; Various harmonic function and triad-related musings
;;;
;;; Possibly most useful to generate potential melodies or skeletons of
;;; such for adaptation into musical works.
;;;
;;;   `clisp -repl harmonic.lisp`
;;; and then (getaphrase) or otherwise fiddle with code
;;; should also work (with warnings, eh) under `sbcl --load harmonic.lisp`
;;;
;;; Something like
;;;   ly-fu --open --relative=c\' ...
;;;
;;; can be used to show & play the notes generated by (getaphrase).

(setq *random-state* (make-random-state t))

(load "util.lisp")

(defconstant +deg-in-octave+ 12)
(defconstant +deg-in-scale+ 7)

; TWEAK use a different scale system if desired
(defparameter *major* '(2 2 1 2 2 2))
(defparameter *minor* '(2 1 2 2 1 2))

(defparameter *notes2pitches* (make-hash-table :test 'equal))
(defparameter *pitches2notes* (make-hash-table))

; input form for notes
(loop for (note pitch) in '((C 0) (D 2) (E 4) (F 5) (G 7) (A 9) (B 11) (C# 1) (D# 3) (E# 5) (F# 6) (G# 8) (A# 10) (B# 0) (Cb 11) (Db 1) (Eb 3) (Fb 4) (Gb 6) (Ab 8) (Bb 10)) do
      (setf (gethash note *notes2pitches*) pitch)
      ; quite possibly a bad idea, but let's see how it works in practice...
      (setf (symbol-value note) pitch))

; output form for notes
(loop for (note pitch) in '((c 0) (cis 1) (d 2) (dis 3) (e 4) (f 5) (fis 6) (g 7) (gis 8) (a 9) (ais 10) (b 11)) do
      (setf (gethash pitch *pitches2notes*) note))

(defun note-of-pitch (&rest pitches)
  (mapcar (lambda (p) (gethash (within-octave p) *pitches2notes*)) pitches))
(defun pitch-of-note (&rest notes)
  (mapcar (lambda (n) (gethash n *notes2pitches*)) notes))

; where we'll be shoving possible pitches to use
(defparameter *field* nil)

; Relic from earlier form, probably easier to keep REPL open and
; copy out potential phrases than re-running the whole lisp thing
; over and over
;(defparameter *duration* (argn-to-integer 0))
;(unless *duration* (setf *duration* 64))

(defun add-note (x)
  (loop for n in (triad-of x C *major*) do
        (push n *field*)))

(defun get-note ()
  (if (zerop (length *field*))
    nil
    (let ((thenote (random-list-item *field*)))
      ; TWEAK move harmony on each note change (alternative would only be
      ; to change it when the harmony is "completed" somehow...)
      (loop for n in (triad-of (advance-harmony) C *major*) do
            (push n *field*))
      ; add the triad (increasing odds 3rd and 5th used) but remove the
      ; used note (to avoid repeated notes; this code generates mostly
      ; what should be considered a harmonic skeleton that may then need
      ; fleshing in)
      (add-note thenote)
      (setf *field* (delete thenote *field*))
      thenote)))

;;; TWEAK harmonic function (which changes the odds of certain notes being
;;; used, and does not really enforce anything otherwise)
(let ((hfp C))
  (defun advance-harmony ()
    (setf hfp (next-harmony hfp)))
  (defun reset-harmony ()
    (setf hfp C)))

;;; TODO use walker alias method implementation instead, and longer
;;; markov chain that would prevent predom -> predom -> predom sorts of
;;; things
;;; TWEAK fiddle with these as needed
(defun next-harmony (current)
  (case current
    (0 (random-list-item '(0 2 4 7 7))) ; tonic
    (2 (random-list-item '(4 7 7 7 7))) ; predom
    (4 (random-list-item '(2 7 7 7 7))) ; other predom (is this needed?)
    (7 (random-list-item '(0 0 0 7))))) ; dominant

(defun reset-things ()
  (reset-harmony)
  (setf *field* nil))

; this could doubtless be improved by pre-calculating all the scale degrees
; and triads of the various scales desired over all starting pitches...
(defun triad-of (x root interval-set)
  (setf x (within-octave x))
  (setf root (within-octave root))
  (let ((idx nil) (scale-degrees (make-array +deg-in-scale+ :fill-pointer 0)))
    (vector-push root scale-degrees)
    (if (= root x) (setf idx 0))
    (loop for i in interval-set do
          (let ((degree (+ i (vector-last scale-degrees))))
            (vector-push degree scale-degrees)
            (if (= degree x) (setf idx (vector-index scale-degrees)))))
    (if idx
      (mapcar (lambda (offset)
                   (elt scale-degrees (% (+ idx offset) +deg-in-scale+)))
           ; mostly the root, sometimes the 3rd, more often the 5th,
           ; and rarely the 7th of the "triad" but TWEAK
           '(0 0 0 0 0 0 0 2 2 2 4 4 4 4 4 6))
      nil)))

(defun within-octave (x) (% x +deg-in-octave+))

(defun getaphrase (&optional (dur 17))
  (reset-things)
  ; TWEAK or adjust to allow starting from any note of the given scale...
  (add-note C)
  (no-return (dotimes (x dur) (format t "~{~a~} " (note-of-pitch (get-note)))))
  (fresh-line)
  (values))
